# -*- coding: utf-8 -*-
"""3B-CABREZA-EXER2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WL1F_WJGRmGDorcjIZ1Opq0soCcbv-Ly

Assessment Task 1: Basic Probability Calculations
"""

def joint_probability(p_A, p_B):
    return p_A * p_B

def marginal_probability(p_A, p_B):
    return p_A + p_B - joint_probability(p_A, p_B)

def conditional_probability(p_B_given_A, p_A, p_B):
    return (p_B_given_A * p_A) / p_B

p_A = 0.3
p_B = 0.4
p_B_given_A = 0.8

print("Joint Probability of A and B:", joint_probability(p_A, p_B))
print("Marginal Probability of A or B:", marginal_probability(p_A, p_B))
print("Conditional Probability of B given A:", conditional_probability(p_B_given_A, p_A, p_B))

"""Assessment Task 2: Bayesian Inference

"""

def bayesian_inference(prior, likelihood_positive_given_disease, likelihood_positive):
    posterior = (likelihood_positive_given_disease * prior) / likelihood_positive
    return posterior

prior_disease = 0.01
likelihood_positive_given_disease = 0.9
likelihood_negative_given_no_disease = 0.95
prevalence_no_disease = 0.99

likelihood_positive = (likelihood_positive_given_disease * prior_disease) + (1 - likelihood_negative_given_no_disease) * prevalence_no_disease

posterior_disease = bayesian_inference(prior_disease, likelihood_positive_given_disease, likelihood_positive)
print(f"Posterior probability of having the disease given a positive test result: {posterior_disease:.4f}")

"""Assessment Task 3: Decision-Making Under Uncertainty

"""

import numpy as np

def simulate_decision(num_simulation, p_success, reward_success, reward_failure):
    outcomes = []
    for _ in range(num_simulation):
        if np.random.rand() < p_success:
            outcomes.append(reward_success)
        else:
            outcomes.append(reward_failure)
    return np.mean(outcomes)

p_success = 0.7
reward_success = 1000
reward_failure = -500

average_outcome = simulate_decision(1000, p_success, reward_success, reward_failure)
print(f"Expected value of decision after 1000 iterations: {average_outcome}")

p_success_new = 0.8
average_outcome_new = simulate_decision(1000, p_success_new, reward_success, reward_failure)
print(f"Expected value of decision with modified success probability (0.8): {average_outcome_new}")

"""Assessment Task 4: Real-World Scenario"""

def probability_rain_given_evidence(p_rain, p_humidity_given_rain, p_cloud_given_rain, p_humidity, p_cloud):
    likelihood = p_humidity_given_rain * p_cloud_given_rain
    evidence = p_humidity * p_cloud
    return (likelihood * p_rain) / evidence

p_rain = 0.2
p_humidity_given_rain = 0.8
p_cloud_given_rain = 0.9
p_humidity = 0.7
p_cloud = 0.6

p_rain_given_evidence = probability_rain_given_evidence(p_rain, p_humidity_given_rain, p_cloud_given_rain, p_humidity, p_cloud)
print(f"Probability of rain given high humidity and cloud cover: {p_rain_given_evidence:.4f}")

"""Assessment Task 5: Probability Distributions Visualization

"""

import numpy as np
import matplotlib.pyplot as plt

def visualize_binomial_distribution(n_trials, p_heads):
    binomial_distribution = np.random.binomial(n=1, p=p_heads, size=n_trials)
    plt.hist(binomial_distribution, bins=2)
    plt.title(f'Binomial Distribution (Coin Flips) - {n_trials} Trials, p_heads={p_heads}')
    plt.xlabel('Outcome (0 = Tails, 1 = Heads)')
    plt.ylabel('Frequency')
    plt.show()

n_trials = 1000
p_heads = 0.5
visualize_binomial_distribution(n_trials, p_heads)

n_trials_new = 2000
p_heads_new = 0.7
visualize_binomial_distribution(n_trials_new, p_heads_new)